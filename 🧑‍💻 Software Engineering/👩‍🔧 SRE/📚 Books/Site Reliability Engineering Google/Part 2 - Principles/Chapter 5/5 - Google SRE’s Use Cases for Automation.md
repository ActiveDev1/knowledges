**موارد استفاده گوگل SRE از اتوماسیون**

در گوگل، ما همه موارد استفاده ذکرشده در بخش قبل (The Use Cases for Automation) و حتی بیشتر را داریم. با این حال، در تیم SRE گوگل، تمرکز اصلی ما معمولاً بر **اجرای زیرساخت‌ها** است، نه مدیریت کیفیت داده‌هایی که از طریق این زیرساخت‌ها منتقل می‌شوند. این تمایز کاملاً مشخص نیست—برای مثال، اگر نیمی از یک مجموعه داده پس از یک push ناپدید شود، ما به شدت به آن اهمیت می‌دهیم و برای تفاوت‌های کلی مانند این هشدار تنظیم می‌کنیم، اما به‌ندرت معادل تغییر ویژگی‌های یک زیرمجموعه دلخواه از حساب‌ها در یک سیستم را می‌نویسیم. بنابراین، زمینه اتوماسیون ما اغلب به مدیریت **چرخه عمر سیستم‌ها**، و نه داده‌های آن‌ها، مربوط است: برای مثال، استقرار یک سرویس در یک کلاستر جدید.

از این نظر، تلاش‌های اتوماسیون SRE چندان با آنچه بسیاری از افراد و سازمان‌های دیگر انجام می‌دهند، متفاوت نیست، جز اینکه ما از ابزارهای متفاوتی برای مدیریت آن استفاده می‌کنیم و تمرکز متفاوتی داریم (که در ادامه بحث خواهیم کرد). ابزارهای رایج مانند Puppet، Chef، cfengine، و حتی Perl، که همگی راه‌هایی برای خودکارسازی وظایف خاص ارائه می‌دهند، عمدتاً در سطح **انتزاع** اجزای ارائه‌شده برای کمک به اتوماسیون متفاوت هستند. یک زبان کامل مانند Perl امکانات سطح POSIX را فراهم می‌کند که در تئوری دامنه نامحدودی از اتوماسیون را در سراسر APIهای قابل‌دسترس سیستم ارائه می‌دهد، در حالی که Chef و Puppet انتزاع‌های آماده‌ای را ارائه می‌کنند که با آن‌ها می‌توان سرویس‌ها یا موجودیت‌های سطح بالاتر را مدیریت کرد.  
اینجا یک معامله کلاسیک وجود دارد: انتزاع‌های سطح بالاتر مدیریت و درک آسان‌تری دارند، اما وقتی با یک **انتزاع نشتی** (leaky abstraction) مواجه می‌شوید، به‌صورت سیستمیک، مکرر، و احتمالاً ناسازگار شکست می‌خورید. برای مثال، ما اغلب فرض می‌کنیم که انتشار یک باینری جدید به یک کلاستر **اتمیک** است؛ کلاستر یا با نسخه قدیمی باقی می‌ماند یا به نسخه جدید ارتقا می‌یابد. اما رفتار دنیای واقعی پیچیده‌تر است: شبکه کلاستر ممکن است در میانه راه قطع شود، ماشین‌ها ممکن است از کار بیفتند، ارتباط با لایه مدیریت کلاستر ممکن است قطع شود و سیستم را در حالت ناسازگار رها کند. بسته به موقعیت، باینری‌های جدید ممکن است آماده شوند اما منتشر نشوند، یا منتشر شوند اما راه‌اندازی مجدد نشوند، یا راه‌اندازی شوند اما قابل‌تأیید نباشند. تعداد کمی از انتزاع‌ها این نوع نتایج را با موفقیت مدل‌سازی می‌کنند و اکثر آن‌ها در نهایت متوقف می‌شوند و نیاز به مداخله دارند. سیستم‌های اتوماسیون واقعاً بد حتی این کار را هم انجام نمی‌دهند.

در SRE فلسفه‌ها و محصولات متعددی در حوزه اتوماسیون دارد. برخی از آن‌ها بیشتر شبیه ابزارهای عمومی عرضه (rollout) هستند بدون مدل‌سازی دقیق موجودیت‌های سطح بالاتر، و برخی دیگر بیشتر شبیه زبان‌هایی برای توصیف استقرار سرویس‌ها در سطحی بسیار انتزاعی هستند. کارهای انجام‌شده در دسته دوم معمولاً **قابل‌استفاده مجدد** و به‌عنوان یک **پلتفرم مشترک** مناسب‌تر هستند، اما پیچیدگی محیط تولیدی ما گاهی به این معناست که رویکرد اول گزینه‌ای فوری‌تر و عملی‌تر است.