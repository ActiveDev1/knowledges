**سلسله‌مراتب کلاس‌های اتوماسیون**

اگرچه تمام این مراحل اتوماسیون ارزشمند هستند و خود پلتفرم اتوماسیون به‌خودی‌خود ارزشمند است، در دنیای ایده‌آل، نیازی به اتوماسیون خارجی نداشتیم. در واقع، به جای داشتن سیستمی که به **منطق چسب خارجی** (glue logic) نیاز دارد، بهتر است سیستمی داشته باشیم که اصلاً نیازی به منطق چسب نداشته باشد. این نه تنها به دلیل **کارایی** بالاتر داخلی‌سازی (که البته مفید است)، بلکه به این دلیل است که سیستم از ابتدا طوری طراحی شده که نیازی به منطق چسب نداشته باشد. برای دستیابی به این هدف، باید موارد استفاده از منطق چسب—که معمولاً دستکاری‌های «مرتبه اول» سیستم مانند افزودن حساب‌ها یا راه‌اندازی سیستم هستند—را مستقیماً در خود برنامه مدیریت کنیم.

به‌عنوان مثالی دقیق‌تر، بیشتر اتوماسیون‌های راه‌اندازی (turnup) در گوگل مشکل‌ساز هستند، زیرا جدا از سیستم اصلی نگهداری می‌شوند و در نتیجه دچار **فرسودگی کد** (bit rot) می‌شوند، یعنی با تغییر سیستم‌های زیرین به‌روز نمی‌شوند. با وجود بهترین نیت‌ها، تلاش برای **اتصال محکم‌تر** این دو (اتوماسیون راه‌اندازی و سیستم اصلی) اغلب به دلیل اولویت‌های ناهماهنگ شکست می‌خورد، زیرا توسعه‌دهندگان محصول، به‌طور منطقی، در برابر نیاز به استقرار آزمایشی برای هر تغییر مقاومت می‌کنند. دوم، اتوماسیونی که حیاتی است اما به‌ندرت اجرا می‌شود و بنابراین آزمایش آن دشوار است، به دلیل چرخه بازخورد طولانی، اغلب به‌ویژه شکننده است. انتقال کلاستر (failover) نمونه‌ای کلاسیک از اتوماسیون با اجرای نادر است: انتقال‌ها ممکن است فقط هر چند ماه یک‌بار رخ دهند، یا به اندازه‌ای کم که ناسازگاری‌هایی بین نمونه‌ها ایجاد شود.

تکامل اتوماسیون مسیری را طی می‌کند:
1. **بدون اتوماسیون**: انتقال پایگاه داده به‌صورت دستی بین مکان‌ها انجام می‌شود.
2. **اتوماسیون خاص سیستم، نگهداری‌شده خارجی**: یک SRE اسکریپت انتقال را در دایرکتوری home خود دارد.
3. **اتوماسیون عمومی، نگهداری‌شده خارجی**: SRE پشتیبانی از پایگاه داده را به یک اسکریپت «انتقال عمومی» که همه استفاده می‌کنند، اضافه می‌کند.
4. **اتوماسیون خاص سیستم، نگهداری‌شده داخلی**: پایگاه داده با اسکریپت انتقال خود ارائه می‌شود.
5. **سیستم‌هایی که نیازی به اتوماسیون ندارند**: پایگاه داده مشکلات را تشخیص می‌دهد و بدون دخالت انسان به‌صورت خودکار انتقال می‌یابد.

تیم SRE از عملیات دستی متنفر است، بنابراین ما به‌وضوح تلاش می‌کند سیستم‌هایی ایجاد کند که به آن‌ها نیازی نداشته باشند. با این حال، گاهی اوقات عملیات دستی اجتناب‌ناپذیر است.

علاوه بر این، نوع فرعی از اتوماسیون وجود دارد که تغییرات را نه در حوزه پیکربندی خاص سیستم، بلکه در کل دامنه تولید اعمال می‌کند. در محیط تولیدی بسیار متمرکز و اختصاصی مانند گوگل، تعداد زیادی تغییرات با دامنه غیرخاص سرویس—مثل تغییر سرورهای Chubby بالادستی، تغییر فلگ در کتابخانه کلاینت Bigtable برای افزایش قابلیت اطمینان دسترسی و غیره—وجود دارد که با این حال باید به‌طور ایمن مدیریت شوند و در صورت لزوم قابل‌برگشت باشند. پس از حجم معینی از تغییرات، انجام دستی تغییرات در کل تولید غیرممکن است و حتی قبل از آن نقطه، نظارت دستی بر فرآیندی که بخش بزرگی از تغییرات یا پیش‌پاافتاده هستند یا با استراتژی‌های ساده «راه‌اندازی مجدد و بررسی» با موفقیت انجام می‌شوند، اتلاف وقت است.

بیایید از مطالعات موردی داخلی برای توضیح دقیق‌تر برخی از نکات بالا استفاده کنیم. مطالعه موردی اول درباره این است که چگونه با کار سخت و دوراندیشانه، به **نیروانای خودخوانده SRE** رسیدیم: خودمان را از شغل‌مان حذف کردیم.


---------------------------------
### مفهوم Glue Logic چیست؟

در اصطلاح **Glue Logic** (منطق چسب) به مجموعه‌ای از کد، اسکریپت‌ها یا فرآیندهای ساده اشاره دارد که برای **اتصال** یا **هماهنگی** بین اجزای مختلف یک سیستم استفاده می‌شود. این منطق معمولاً برای پر کردن شکاف‌های عملکردی بین سیستم‌ها یا ابزارهایی به کار می‌رود که به‌صورت مستقیم با یکدیگر سازگار نیستند یا برای انجام وظایف خاصی نیاز به هماهنگی اضافی دارند. به عبارت دیگر، glue logic مانند «چسب» عمل می‌کند که اجزای مختلف را به هم متصل می‌کند تا سیستم به‌درستی کار کند، اما خودش بخشی از منطق اصلی سیستم نیست.

### ویژگی‌های Glue Logic:

- **موقتی یا خاص**: اغلب به‌صورت راه‌حل‌های موقتی یا خاص برای یک مشکل خاص نوشته می‌شود.
- **سادگی**: معمولاً شامل اسکریپت‌ها یا کدهای ساده است که کارهای خاصی مانند انتقال داده، تغییر فرمت، یا اجرای متوالی وظایف را انجام می‌دهند.
- **خارجی بودن**: اغلب خارج از سیستم اصلی نوشته و نگهداری می‌شود، که می‌تواند منجر به مشکلاتی مثل **فرسودگی کد** (bit rot) شود، یعنی وقتی سیستم اصلی تغییر می‌کند، glue logic به‌روز نمی‌شود و ناسازگار می‌شود.

### مثال ساده:

فرض کنید یک سیستم پایگاه داده (مثل MySQL) دارید که باید با یک برنامه وب ارتباط برقرار کند، اما این دو سیستم از فرمت‌های متفاوتی برای تبادل داده استفاده می‌کنند. مثلاً:

- پایگاه داده خروجی را به‌صورت JSON تولید می‌کند.
- برنامه وب انتظار دارد داده‌ها به‌صورت XML دریافت شوند.

برای حل این مشکل، یک اسکریپت ساده (مثلاً به زبان Python) می‌نویسید که داده‌های JSON را از پایگاه داده می‌گیرد، آن‌ها را به XML تبدیل می‌کند و به برنامه وب تحویل می‌دهد. این اسکریپت **glue logic** است، چون:

- وظیفه اصلی سیستم (ذخیره داده یا ارائه وب) را انجام نمی‌دهد.
- فقط شکاف بین دو سیستم را پر می‌کند تا با هم کار کنند.
- اگر پایگاه داده یا برنامه وب تغییر کند (مثلاً فرمت داده عوض شود)، این اسکریپت ممکن است دیگر کار نکند، مگر اینکه به‌روز شود.

### چرا مشکل‌ساز است؟

در متن، اشاره شده که glue logic اغلب به‌صورت **خارجی** از سیستم اصلی نگهداری می‌شود (مثل اسکریپت‌های جداگانه). این باعث می‌شود که اگر سیستم اصلی تغییر کند، glue logic به‌روز نشود و مشکلاتی مثل ناسازگاری یا خرابی ایجاد شود. به همین دلیل، هدف ایده‌آل این است که سیستم‌ها طوری طراحی شوند که نیازی به glue logic نداشته باشند (مثلاً با ادغام این منطق در خود سیستم).

### مثال واقعی‌تر از متن:

در متن، به اتوماسیون راه‌اندازی (turnup) در گوگل اشاره شده که اغلب به‌صورت glue logic خارجی نوشته می‌شود (مثل اسکریپت‌هایی برای راه‌اندازی کلاسترها). این اسکریپت‌ها اگر با تغییرات سیستم اصلی هماهنگ نشوند، دچار **فرسودگی کد** می‌شوند و کارایی خود را از دست می‌دهند. راه‌حل ایده‌آل این است که این منطق به‌صورت داخلی در خود سیستم (مثل پایگاه داده یا سرویس) ادغام شود تا نیازی به اسکریپت‌های خارجی نباشد.


-------------------------

 **نیروانای خودخوانده SRE** چیست؟
 
 **نیروانای خودخوانده SRE** به وضعیتی اشاره دارد که در آن مهندسان SRE (Site Reliability Engineering) از طریق **اتوماسیون کامل** وظایف خود را به‌گونه‌ای خودکار می‌کنند که نیاز به دخالت دستی انسان در عملیات روزمره سیستم به حداقل یا حتی به صفر برسد. این اصطلاح به‌صورت طنزآمیز بیان می‌کند که SREها به‌قدری در خودکارسازی فرآیندها موفق شده‌اند که عملاً «خودشان را از شغل‌شان حذف کرده‌اند»، زیرا سیستم‌ها به‌طور خودمختار و بدون نیاز به نظارت یا مداخله انسانی کار می‌کنند.

### توضیح ساده:

این مفهوم از مطالعه موردی پایگاه داده تبلیغات گوگل (Ads Database) در متن گرفته شده است، جایی که تیم SRE با توسعه **Decider** (یک daemon خودکار برای انتقال‌های MySQL)، زمان قطعی (downtime) را به کمتر از 30 ثانیه کاهش داد و کارهای عملیاتی روزمره را تا 95% حذف کرد. این اتوماسیون به تیم اجازه داد تا زمان خود را صرف بهبودهای دیگر کنند، به‌جای مدیریت دستی مشکلات تکراری. در نتیجه، آن‌ها به نقطه‌ای رسیدند که سیستم تقریباً به‌صورت خودکار اداره می‌شد، که به‌عنوان «نیروانای SRE» توصیف می‌شود—یعنی سیستمی که نیازی به دخالت مداوم انسان ندارد.

### چرا «نیروانا»؟

- در فلسفه بودایی، نیروانا به حالتی از رهایی کامل اشاره دارد. در اینجا، نیروانای SRE به رهایی از کارهای دستی خسته‌کننده و تکراری اشاره دارد.
- این حالت ایده‌آل است، زیرا هدف SRE ایجاد سیستم‌هایی با **قابلیت اطمینان بالا**، **مقیاس‌پذیری**، و **مدیریت‌پذیری** با حداقل تلاش انسانی است.